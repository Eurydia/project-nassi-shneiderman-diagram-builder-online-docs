# Parser

The parser is responsible for generating an AST from the tokens generated by the lexer.

I have no idea what is the correct terminology for this, but the parser recursively calls itself to generate an AST.

The parser is implemented in `src/interpreter/parser.ts`.

The interface of the module is as follows:

```ts
// src/interpreter/parser.ts
export enum ASTNodeKind {}

export type ASTNodeEnd;
export type ASTNodeProcess;
export type ASTNodeLoopFirst;
export type ASTNodeLoopLast;
export type ASTNodeIfElse;
export type ASTNode;

export type Parser;

export const parserInit: (tokens: Token[]) => Parser;
export const parserGetAllNodes: (p: Parser) => ASTNode[];

const parserGetNextNodeThenAdvance = (p: Parser) => ASTNode
const parserSafeGetNextTokenThenAdvance: (p: Parser) => Token;

const parserBuildLoopFirstNode = (p: Parser) => ASTNodeLoopFirst;
const parserBuildLoopLastNode = (p: Parser) => ASTNodeLoopLast;
const parserBuildIfElseNode = (p: Parser) => ASTNodeIfElse;
```

Let's discuss each of these in detail.

## `ASTNodeKind` enum

```ts
export enum ASTNodeKind {
	END = 0,
	PROCESS,
	LOOP_FIRST,
	LOOP_LAST,
	IF_ELSE,
}
```

The `ASTNodeKind` enum represents the type of an AST node.
It represents every kind of AST node that the parser can generate and recongize.

The only thing worth noting is that for statements and while statements are represented as `ASTNodeKind.LOOP_FIRST` node.

## `ASTNode` type

```ts
export type ASTNode =
	| ASTNodeEnd
	| ASTNodeProcess
	| ASTNodeLoopFirst
	| ASTNodeLoopLast
	| ASTNodeIfElse;
```

The `ASTNode` type represents an AST node.
In this case, it is a discriminated union of all the possible AST nodes.
Though this is not the most efficient way to represent an AST node, it is the most convenient way to represent an AST node.

### `ASTNodeEnd` type

```ts
export type ASTNodeEnd = {
	kind: ASTNodeKind.END;
};
```

The `ASTNodeEnd` type represents the end of the AST.

### `ASTNodeProcess` type

```ts
export type ASTNodeProcess = {
	kind: ASTNodeKind.PROCESS;
	body: Token[];
};
```

The `ASTNodeProcess` type represents generic processes.

### `ASTNodeLoopFirst` type

```ts
export type ASTNodeLoopFirst = {
	kind: ASTNodeKind.LOOP_FIRST;
	condition: Token[];
	body: ASTNode[];
};
```

The `ASTNodeLoopFirst` type represents for statements and while statements.

### `ASTNodeLoopLast` type

```ts
export type ASTNodeLoopLast = {
	kind: ASTNodeKind.LOOP_LAST;
	condition: Token[];
	body: ASTNode[];
};
```

The `ASTNodeLoopLast` type represents do-while statements.

### `ASTNodeIfElse` type

```ts
export type ASTNodeIfElse = {
	kind: ASTNodeKind.IF_ELSE;
	condition: Token[];
	bodyIf: ASTNode[];
	bodyElse: ASTNode[];
};
```

The `ASTNodeIfElse` type represents if-else statements.

## `Parser` type

```ts
export type Parser = {
	tokens: Token[];
	tokenLength: number;
	cursorPos: number;
};
```

The `Parser` type represents the parser.
It is a simple object with three properties: `tokens`, `tokenLength`, and `cursorPos`.

Parsers should be initialized using the `parserInit` function to ensure that the input is properly sanitized.

To generate an AST, the parser uses the `parserGetAllNodes` function which returns a list of `ASTNode`.

### `Parser.tokens` property

`Parser.tokens` stores the tokens generated by the lexer.
This list is not explicitly immutable, but the parser does not change the list in any way.

### `Parser.tokenLength` property

`Parser.tokenLength` stores the length of the `Parser.tokens` list.
I just added this property to avoid calling `Parser.tokens.length` multiple times.

### `Parser.cursorPos` property

`Parser.cursorPos` stores the current position of the parser in the `Parser.tokens` list.
It keeps track of the current position of the parser in the `Parser.tokens` list, and instead of modifying the `Parser.tokens` list, the parser advances the cursor.

## `parserInit` function

```ts
export const parserInit: (
	tokens: Token[],
) => Parser;
```

The `parserInit` function initializes a parser.
It takes a list of tokens as input and returns a parser.

## `parserGetAllNodes` function

```ts
export const parserGetAllNodes: (
	p: Parser,
) => ASTNode[];
```

The `parserGetAllNodes` function generates an AST from the tokens generated by the lexer.
It takes a parser as input and returns a list of AST nodes.

Internally, it repeatedly calls the `parserGetNextNodeThenAdvance` function to generate the AST.
It terminates when it reaches an `ASTNodeKind.END` node, in which case it returns the list of collected AST nodes.

Note that this function does not return the `ASTNodeKind.END` node.

## `parserGetNextNodeThenAdvance` function

```ts
const parserGetNextNodeThenAdvance: (
	p: Parser,
) => ASTNode;
```

The `parserGetNextNodeThenAdvance` does the majority of the work in building the AST.

If the `Parser.cursorPos` is greater than or equal to `Parser.tokenLength`, it returns an `ASTNodeKind.END` node.

Internally, it calls `parserSafeGetNextTokenThenAdvance` to collect the current token and advance the cursor.

If the current token is a `TokenKind.KEYWORD` token, it calls the appropriate `parserBuild` function to build the AST node.

If not, it keeps calling `parserGetNextNodeThenAdvance` until it reaches a `TokenKind.SEMICOLON` token and return an `ASTNodeKind.PROCESS` node with collected tokens as the body.

## `parserSafeGetNextTokenThenAdvance` function

```ts
const parserSafeGetNextTokenThenAdvance: (
	p: Parser,
) => Token;
```

The `parserSafeGetNextTokenThenAdvance` function collects the current token and advances the cursor.

If the `Parser.cursorPos` is greater than or equal to `Parser.tokenLength`, it returns a `TokenKind.END` token to prevent index out of bounds error.

## `parserBuildLoopFirstNode` function

```ts
const parserBuildLoopFirstNode: (
	p: Parser,
) => ASTNodeLoopFirst;
```

The `parserBuildLoopFirstNode` function builds an `ASTNodeKind.LOOP_FIRST` node.

First, it expects the current token to be a `TokenKind.LEFT_PAREN` token.

Then, it collects the "condition" tokens by repeatedly calling `parserSafeGetNextTokenThenAdvance` until it reaches a `TokenKind.RIGHT_PAREN` token.

Then, it expects the current token to be a `TokenKind.LEFT_BRACE` token.

Then, it collects the "body" nodes by repeatedly calling `parserGetNextNodeThenAdvance` until it reaches a `TokenKind.RIGHT_BRACE` token.

Once it reaches a `TokenKind.RIGHT_BRACE` token, it calls `parserGetNextNodeThenAdvance` to advance the cursor.
This effectly recursively builds the body of the loop.

Then, it returns an `ASTNodeKind.LOOP_FIRST` node with collected "condition" tokens and "body" nodes.

## `parserBuildLoopLastNode` function

```ts
const parserBuildLoopLastNode: (
	p: Parser,
) => ASTNodeLoopLast;
```

The `parserBuildLoopLastNode` function builds an `ASTNodeKind.LOOP_LAST` node.

First, it expects the current token to be a `TokenKind.LEFT_BRACE` token.

Then, it collects the "body" nodes by repeatedly calling `parserGetNextNodeThenAdvance` until it reaches a `TokenKind.RIGHT_BRACE` token.

Once it reaches a `TokenKind.RIGHT_BRACE` token, it calls `parserGetNextNodeThenAdvance` to advance the cursor.

Then, it expects the current token to be a `TokenKind.KEYWORD` token.

Then, it collects the "condition" tokens by repeatedly calling `parserSafeGetNextTokenThenAdvance` until it reaches a `TokenKind.SEMICOLON` token.

Then, it returns an `ASTNodeKind.LOOP_LAST` node with collected "condition" tokens and "body" nodes.

## `parserBuildIfElseNode` function

```ts
const parserBuildIfElseNode: (
	p: Parser,
) => ASTNodeIfElse;
```

The `parserBuildIfElseNode` function builds an `ASTNodeKind.IF_ELSE` node.

First, it expects the current token to be a `TokenKind.LEFT_PAREN` token.

Then, it collects the "condition" tokens by repeatedly calling `parserSafeGetNextTokenThenAdvance` until it reaches a `TokenKind.RIGHT_PAREN` token.

Then, it expects the current token to be a `TokenKind.LEFT_BRACE` token.

Then, it collects the "bodyIf" nodes by repeatedly calling `parserGetNextNodeThenAdvance` until it reaches a `TokenKind.RIGHT_BRACE` token.

Once it reaches a `TokenKind.RIGHT_BRACE` token, it calls `parserGetNextNodeThenAdvance` to advance the cursor.

By this point, if the current token is a `TokenKind.KEYWORD` token, with text "else", it collects the "bodyElse" nodes by repeatedly calling `parserGetNextNodeThenAdvance` until it reaches a `TokenKind.RIGHT_BRACE` token.

Then, it returns an `ASTNodeKind.IF_ELSE` node with collected "condition" tokens, "bodyIf" nodes, and "bodyElse" nodes.
