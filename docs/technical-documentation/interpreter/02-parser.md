# Parser

The parser builds an [abstract syntax trees](https://en.wikipedia.org/wiki/Abstract_syntax_tree) from tokens generated by the lexer.
Its implemention can be found at the [parser](https://github.com/Eurydia/project-nassi-shneiderman-diagram-builder-online/blob/1bf484c9082dc5ea0fcfc6cf37121d273f7831b5/src/interpreter/parser.ts) module.

The interface of the module is as follows:

```ts
// src/interpreter/parser.ts
export enum ASTNodeKind {}

export type ASTNodeEnd;
export type ASTNodeProcess;
export type ASTNodeLoopFirst;
export type ASTNodeLoopLast;
export type ASTNodeIfElse;
export type ASTNode;

export type Parser;

export const parserInit: (tokens: Token[]) => Parser;
export const parserGetAllNodes: (p: Parser) => ASTNode[];

const parserGetNextNodeThenAdvance = (p: Parser) => ASTNode
const parserSafeGetNextTokenThenAdvance: (p: Parser) => Token;

const parserBuildLoopFirstNode = (p: Parser) => ASTNodeLoopFirst;
const parserBuildLoopLastNode = (p: Parser) => ASTNodeLoopLast;
const parserBuildIfElseNode = (p: Parser) => ASTNodeIfElse;
```

## `ASTNodeKind` enum

```ts
export enum ASTNodeKind {
	END = 0,
	PROCESS,
	LOOP_FIRST,
	LOOP_LAST,
	IF_ELSE,
}
```

The `ASTNodeKind` enum represents the type of an AST node.

It represents node that the parser can build and recongize.

### `ASTNodeKind.END`

`ASTNodeKind.END` represents the end of an abstract syntax tree.

This node kind tells the parser to terminate.

### `ASTNodeKind.PROCESS`

`ASTNodeKind.PROCESS` represents a process block.

### `ASTNodeKind.LOOP_FIRST`

`ASTNodeKind.LOOP_FIRST` represents a test-first loop block, which includes both for loops and while loops.

### `ASTNodeKind.LOOP_LAST`

`ASTNodeKind.LOOP_FIRST` represents a test-last loop block or do-while loops.

### `ASTNodeKind.IF_ELSE`

`ASTNodeKind.IF_ELSE` represents a branching block, which includes both if blocks and if-else blocks.

## `ASTNode` type

```ts
export type ASTNode =
	| ASTNodeEnd
	| ASTNodeProcess
	| ASTNodeLoopFirst
	| ASTNodeLoopLast
	| ASTNodeIfElse;
```

The `ASTNode` type represents a node in an abstract syntax tree.

### `ASTNodeEnd` type

```ts
export type ASTNodeEnd = {
	kind: ASTNodeKind.END;
};
```

The `ASTNodeEnd` type represents the end node.

The sole purpose of this node type is to terminate the parser.

### `ASTNodeProcess` type

```ts
export type ASTNodeProcess = {
	kind: ASTNodeKind.PROCESS;
	body: Token[];
};
```

The `ASTNodeProcess` type represents a process block.

The content of the process is stored in the `body` property.

### `ASTNodeLoopFirst` type

```ts
export type ASTNodeLoopFirst = {
	kind: ASTNodeKind.LOOP_FIRST;
	condition: Token[];
	body: ASTNode[];
};
```

The `ASTNodeLoopFirst` type represents test-first loop blocks.

### `ASTNodeLoopLast` type

```ts
export type ASTNodeLoopLast = {
	kind: ASTNodeKind.LOOP_LAST;
	condition: Token[];
	body: ASTNode[];
};
```

The `ASTNodeLoopLast` type represents test-last loop blocks.

### `ASTNodeIfElse` type

```ts
export type ASTNodeIfElse = {
	kind: ASTNodeKind.IF_ELSE;
	condition: Token[];
	bodyIf: ASTNode[];
	bodyElse: ASTNode[];
};
```

The `ASTNodeIfElse` type represents if blocks and if-else blocks.

## `Parser` type

```ts
export type Parser = {
	tokens: Token[];
	tokenLength: number;
	cursorPos: number;
};
```

The `Parser` type represents a parser.

It has three properties: `tokens`, `tokenLength`, and `cursorPos`.

Parsers should be initialized using the `parserInit` function.

To generate an AST, the parser uses the `parserGetAllNodes` function which returns a list of `ASTNode`.

### `Parser.tokens` property

`Parser.tokens` stores the tokens generated by the lexer.

This list is not explicitly immutable, but the parser does not change the list in any way.

### `Parser.tokenLength` property

`Parser.tokenLength` stores the length of the `Parser.tokens` list.

I just added this property to avoid calling `Parser.tokens.length` multiple times.

### `Parser.cursorPos` property

`Parser.cursorPos` stores the current position of the cursor.

## `parserInit` function

```ts
export const parserInit: (
	tokens: Token[],
) => Parser;
```

The `parserInit` function initializes a parser.

It takes a list of tokens as input and returns a parser object.

## `parserGetAllNodes` function

```ts
export const parserGetAllNodes: (
	p: Parser,
) => ASTNode[];
```

The `parserGetAllNodes` function generates a list of `ASTNode`.

Internally, it repeatedly calls the `parserGetNextNodeThenAdvance` function.
It terminates when it reaches an `ASTNodeKind.END` node, in which case it returns the list of collected AST nodes.

Note that this function does not return the `ASTNodeKind.END` node.

## `parserGetNextNodeThenAdvance` function

```ts
const parserGetNextNodeThenAdvance: (
	p: Parser,
) => ASTNode;
```

The `parserGetNextNodeThenAdvance` does the majority of the work in building the AST.

If the `Parser.cursorPos` is greater than or equal to `Parser.tokenLength`, it returns an `ASTNodeKind.END` node.

Internally, it calls `parserSafeGetNextTokenThenAdvance` to collect the current token and advance the cursor.

If the current token is a `TokenKind.KEYWORD` token, it calls the appropriate `parserBuild` function to build the AST node.

If not, it keeps calling `parserGetNextNodeThenAdvance` until it reaches a `TokenKind.SEMICOLON` token and return an `ASTNodeKind.PROCESS` node with collected tokens as the body.

## `parserSafeGetNextTokenThenAdvance` function

```ts
const parserSafeGetNextTokenThenAdvance: (
	p: Parser,
) => Token;
```

The `parserSafeGetNextTokenThenAdvance` function collects the current token and advances the cursor.

If the `Parser.cursorPos` is greater than or equal to `Parser.tokenLength`, it returns a `TokenKind.END` token to prevent index out of bounds error.

## `parserBuildLoopFirstNode` function

```ts
const parserBuildLoopFirstNode: (
	p: Parser,
) => ASTNodeLoopFirst;
```

The `parserBuildLoopFirstNode` function builds an `ASTNodeKind.LOOP_FIRST` node.

First, it expects the current token to be a `TokenKind.LEFT_PAREN` token.

Then, it collects the "condition" tokens by repeatedly calling `parserSafeGetNextTokenThenAdvance` until it reaches a `TokenKind.RIGHT_PAREN` token.

Then, it expects the current token to be a `TokenKind.LEFT_BRACE` token.

Then, it collects the "body" nodes by repeatedly calling `parserGetNextNodeThenAdvance` until it reaches a `TokenKind.RIGHT_BRACE` token.

Once it reaches a `TokenKind.RIGHT_BRACE` token, it calls `parserGetNextNodeThenAdvance` to advance the cursor.
This effectly recursively builds the body of the loop.

Then, it returns an `ASTNodeKind.LOOP_FIRST` node with collected "condition" tokens and "body" nodes.

## `parserBuildLoopLastNode` function

```ts
const parserBuildLoopLastNode: (
	p: Parser,
) => ASTNodeLoopLast;
```

The `parserBuildLoopLastNode` function builds an `ASTNodeKind.LOOP_LAST` node.

First, it expects the current token to be a `TokenKind.LEFT_BRACE` token.

Then, it collects the "body" nodes by repeatedly calling `parserGetNextNodeThenAdvance` until it reaches a `TokenKind.RIGHT_BRACE` token.

Once it reaches a `TokenKind.RIGHT_BRACE` token, it calls `parserGetNextNodeThenAdvance` to advance the cursor.

Then, it expects the current token to be a `TokenKind.KEYWORD` token.

Then, it collects the "condition" tokens by repeatedly calling `parserSafeGetNextTokenThenAdvance` until it reaches a `TokenKind.SEMICOLON` token.

Then, it returns an `ASTNodeKind.LOOP_LAST` node with collected "condition" tokens and "body" nodes.

## `parserBuildIfElseNode` function

```ts
const parserBuildIfElseNode: (
	p: Parser,
) => ASTNodeIfElse;
```

The `parserBuildIfElseNode` function builds an `ASTNodeKind.IF_ELSE` node.

First, it expects the current token to be a `TokenKind.LEFT_PAREN` token.

Then, it collects the "condition" tokens by repeatedly calling `parserSafeGetNextTokenThenAdvance` until it reaches a `TokenKind.RIGHT_PAREN` token.

Then, it expects the current token to be a `TokenKind.LEFT_BRACE` token.

Then, it collects the "bodyIf" nodes by repeatedly calling `parserGetNextNodeThenAdvance` until it reaches a `TokenKind.RIGHT_BRACE` token.

Once it reaches a `TokenKind.RIGHT_BRACE` token, it calls `parserGetNextNodeThenAdvance` to advance the cursor.

By this point, if the current token is a `TokenKind.KEYWORD` token, with text "else", it collects the "bodyElse" nodes by repeatedly calling `parserGetNextNodeThenAdvance` until it reaches a `TokenKind.RIGHT_BRACE` token.

Then, it returns an `ASTNodeKind.IF_ELSE` node with collected "condition" tokens, "bodyIf" nodes, and "bodyElse" nodes.
